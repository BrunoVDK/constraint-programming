\section{Sudoku}

Sudoku is a well-known puzzle game which needs no introduction. It is typically modelled as a constraint satisfaction problem through the use of \texttt{all\_different} constraints on rows, columns and blocks. Such global inequalities tend to improve upon the use of binary inequalities. The constraint generating code\footnote{\texttt{ECLiPSe} and \texttt{CHR} implementations are available in \texttt{/sudoku/model/classic.pl} and in \texttt{/sudoku/chr/model/classic.pl}.} is fairly trivial and needn't be detailed here. \\\par

There are several other ways one could model Sudoku. The widely cited study by Helmut Simonis \cite{article:simonis} and subsequent studies provide some ideas. Four \textit{`dual'} models, two approaches based on a boolean characterisation, a combination of models provided by Laburthe, a model enforcing the singular occurrence of every value in every row, column and block, as well as a model with nothing but channeling constraints were considered\footnote{These are implemented with ECLiPSe in the \texttt{/sudoku/eclipse/model/} directory, and some CHR versions are in \texttt{/sudoku/chr/model/}.}. Tests were run on the provided puzzles\footnote{\texttt{/sudoku/benchmarks/benchmarks.pl} provides automatic benchmarking code.} as well as some minimum puzzles provided by Gordon Royle\footnote{\href{http://rotor.di.unipi.it/cisterni/Shared\%20Documents/minsudoku.html}{These are available online.}}. These are puzzles with a minimal amount of pre-filled cells (17 to be precise \cite{article:mcguire}), which does not mean that they are harder to solve. \\\par

The dual models hold a $N\times N$ array with all the decision variables. Whereas in the classic viewpoint the rows, columns and values of this array correspond to those of the input puzzle, every one of the four dual models changes their roles. The first two switch the role of rows or columns with those of values. In the third model every row and column of the array corresponds to a block and a position. In the fourth dual model every row represents a block, every column a value and every value a position within a block. For each of them it was harder to implement the necessary constraints, usually necessitating the use of auxiliary variables together with appropriate channeling constraints.\\\par  

In one of his works Laburthe discusses various rules that can be used to resolve Sudoku puzzles, after which he details three models that he associates with the rules \cite{article:laburthe}. He ends up proposing a model for every level of difficulty of the input puzzle. An attempt was made at implementing his recommendation for `difficult' puzzles. It decreased the average number of backtracks but increased the runtime. \\\par

The boolean models include the natural combined model \cite{article:natural} and a more intuitive characterisation resembling an integer programming - or a SAT model \cite{article:sat} (using \texttt{ic\_global:occurrences/3} instead of sums, disjunctions and conjunctions). Both of them have $N\times N\times N$ boolean variables $b_{rcv}$ which are true if the cell at row $r$ and column $c$ holds the value $v$. The natural combined model was cumbersome to implement and performed badly. It was introduced together with an algorithm which was tailored after it, and a constraint for unequality of lists isn't really supported by ECLiPSe\footnote{A custom-made implementation as well as the \href{https://eclipseclp.org/doc/bips/kernel/termcomp/TE-2.html}{\texttt{$\sim$=/2}} constraint which checks if two terms can be unified were tried. Channeling back to integers with \texttt{ic\_global:bool\_channeling/3} worked better.}.\par
Note that it is usually not recommended to use a boolean model when integers can be used instead (as pointed out by Rossi \cite{book:rossi}).\\\par
% Rossi is p. 393

The last two models were found to be the most performant. The first makes use of the previously mentioned \texttt{occurrences/3} constraint to make every value occur just once in every row, column and block. 
\par The second one generates nothing but channeling constraints. It has been demonstrated that this can provide good results despite such constraints being less `tight' than \texttt{all\_different} constraints\footnote{\textit{``The reason for this difference is that the primal not-equals constraints detect singleton variables (i.e. those variables with a single value), the channelling constraints detect singleton variables and singleton values (i.e. those values which occur in the domain of a single variable), whilst the primal all-different constraint detects global consistency (which includes singleton variables, singleton values and many other situations)"}\cite{article:channeling}}. When Dot\'u discussed it he was considering QuasiGroups \cite{article:quasi}. This was extended\footnote{The code lies in \texttt{sudoku/model/channeling.pl} in which a flag called \texttt{extended} can be used to opt for one of two variants.} to Sudoku puzzles by making use of three instead of two dual models (since blocks need to be considered as well). The variant in which channeling constraints between all models (one primal, three dual) are generated performed better than the one in which only channeling constraints between the primal and every dual model are applied. These variants are analogous to what Dot\'u referred to as \textit{`trichanneling'} and \textit{`bichanneling'}.\\\par

\subsection{Experiments}

Number of backtracks and running time for most of the models are displayed in table 1. Removal of \textit{`big'} (\texttt{all\_different}) constraints in the classic model\footnote{In his study Demoen gives several \textit{Missing(6)} examples, models in which 6 of the \texttt{all\_different} constraints are removed. \textit{Missing(7)} models aren't Sudoku, and because of the stark rise in number of backtracks no further experimentation with the removal of `\textit{small}' constraints was done. The \texttt{eliminate\_redundancy} flag can be used to toggle redundancy elimination on and off.} led to an increase in runtime which corroborates Demoen's experiments \cite{article:demoen}. \\\par

One interesting observation is that the two most performant models also have the same number of backtracks. One of them is the model with nothing but channeling constraints, the other uses the \texttt{occurrences/3} constraint. This constraint enforces arc consistency.\\\par

A model combining the classic viewpoint with the fourth dual model was set up. Number of backtracks and runtimes are displayed in table \ref{tab:res1}.

\begin{algorithm}[H]
\caption{Dual viewpoint constraints}\label{channeling}
\small
Code here\\
More code here\\
Even more code here
\end{algorithm}

>> Two tables: one with all results with ic:alldifferent and just fixed heuristics (input\_order). Then a table for ic\_global + heuristics for the chosen 2 models (channeling and dual3 or dual4), this time each puzzle separately. Then a small discussion of the results. Should be 3 pages in total including TOC. Note that small discussion of CHR needs to be done too.

>> Maybe for those puzzles that do better with input\_order show that mirroring the puzzle leads to slower runtimes (you could do this for all puzzles, write procedure swap(Puzzle) for it). Note that value heuristics shouldn't matter much as the 'max' or 'min' isn't  really meaningful in Sudoku (you can use '9,8,7, ...' instead of '1,2,3,...' for all we know

%\setlength\arrayrulewidth{0.5pt}
%\taburulecolor{gray}
\begin{table}[]
\bgroup
\def\arraystretch{1.3}
\begin{tabular}{ccccc}
\multicolumn{1}{l}{}    & \texttt{input\_order} & \texttt{first\_fail} & \texttt{input\_order} + \texttt{ic\_global} & \texttt{first\_fail} + \texttt{ic\_global} \\ \hline
\textit{lambda}          &              &             &                           &                          \\
\textit{hard17}          &              &             &                           &                          \\
\textit{eastermonster}   &              &             &                           &                          \\
\textit{tarek\_052}      &              &             &                           &                          \\
\textit{goldennugget}    &              &             &                           &                          \\
\textit{coloin}          &              &             &                           &                          \\
\textit{extra2}          &              &             &                           &                          \\
\textit{extra3}          &              &             &                           &                          \\
\textit{extra4}          &              &             &                           &                          \\
\textit{inkara2012}      &              &             &                           &                          \\
\textit{clue18}          &              &             &                           &                          \\
\textit{clue17}          &              &             &                           &                          \\
\textit{sudowiki\_nb28}  &              &             &                           &                          \\
\textit{sudowiki\_nb49}  &              &             &                           &                          \\\hline
Total           &              &             &                           &                          \\
Total (minimum) &              &             &                           &                         
\end{tabular}
\egroup
\caption{Results (ECLiPSe)}
\label{tab:res1}
\end{table}